垃圾收集（Garbage Collection，简称GC）

### 我们为什么需要垃圾收集和内存分配？ 
当需要排查各种内存 溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动 化”的技术实施必要的监控和调节。


# 引用算法(主流java虚拟机没有用到)
原理：在对象中添加一个引用计数器，当对象被引用时，引用计数器加1，当引用失效时，引用计数器减1。任何时刻引用计数器为0的对象就是不能再被使用的
优点：原理简单，判定效率高
缺点：案例 
public class ReferenceCountingGC {  
       public Object instance = null; 
       private static final int _1MB = 1024 * 1024; 
/*** 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过 */ 
       private byte[] bigSize = new byte[2 * _1MB]; 
      public static void testGC() { ReferenceCountingGC objA = new ReferenceCountingGC(); 		  	ReferenceCountingGC objB = new ReferenceCountingGC(); 
	objA.instance = objB; 
	objB.instance = objA; 
	objA = null; objB = null; // 假设在这行发生GC，objA和objB是否能被回收？ 
	System.gc(); 
	}
}



# 可达性分析算法
原理：是通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。
在Java技术体系里面，固定可作为GC Roots的对象包括以下几种： ·在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。 ·在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
·在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
·在本地方法栈中JNI（即通常所说的Native方法）引用的对象。 
·Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。 ·
所有被同步锁（synchronized关键字）持有的对象。 
·反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等


# 标记-清除算法
原理：首先标记出所有需要回 收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回 收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程
缺点：执行效率不稳定、内存空间碎片化

# 标记-复制算法
解决执行效率低的问题
原理：它将可用 内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着 的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
缺点：如果内存中多数对象都是存 活的，这种算法将会产生大量的内存间复制的开销、可用内存缩小为了原来的一半，空间浪费未免太多了一 点


# 标记-整理算法
原理：其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可 回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内 存
# 对象的创建
加载：先去检测new指令能否再常量池中定位到一个类的符号引用，如果未被加载、解析、初始化过 执行相应的类加载过程

分配内存: 为对象分配空间时采用指针碰撞或者空闲列表，如果java虚拟机采用serial、parnew等压缩整理过程的收集器时采用指针碰撞算法，当使用CMS这种基于清除	整理过程的收集器时用空间列表

初始化: Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到 类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息
Java编译器会在遇到new关键字的地方同时生成 这两条字节码指令，new指令之后会接着执行<init> ()方法

# 对象的内存布局
对象头: 对象头中包含两个信息：用于存储对象自身的运行时数据、类型指针。
存储对象自身的运行时数据：哈 希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
类型指针：Java虚拟机通过这个指针 来确定该对象是哪个类的实例，但并不是所有的虚拟机实现都必须在对象数据上保留类型指针 

实例数据：对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字 段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。

对齐填充：这并不是必然存在的，

# 对象的访问定位
Java程序通过栈上的reference数据来操作堆上的具 体对象。主流的访问方式主要有使用句柄和直接指针
句柄：Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就 是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息     
优点：稳定句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference本身不需要被修改  
直接指针：Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关 信息，reference中存储的直接就是对象地址        
优点：使用直接指针来访问最大的好处就是速度更快
